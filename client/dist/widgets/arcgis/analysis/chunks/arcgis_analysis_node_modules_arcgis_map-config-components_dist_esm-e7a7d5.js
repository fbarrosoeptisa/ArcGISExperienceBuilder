/*! For license information please see arcgis_analysis_node_modules_arcgis_map-config-components_dist_esm-e7a7d5.js.LICENSE.txt */
"use strict";(self.webpackChunkexb_client=self.webpackChunkexb_client||[]).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_map-config-components_dist_esm-e7a7d5"],{97127:(t,e,o)=>{o.d(e,{a:()=>c,c:()=>i,g:()=>u,m:()=>pt,r:()=>P,u:()=>Z});var s=class{resolve(t){}reject(t){}constructor(){this.promise=new Promise(((t,e)=>{this.resolve=t,this.reject=e}))}};function n(t,e,o){const{subscribe:s}=function(t){const e=t.join(","),o=r[e];if(void 0!==o)return o;const s=new Set,n=new MutationObserver((t=>s.forEach((e=>e(t)))));globalThis.document&&n.observe(document.documentElement,{attributes:!0,attributeFilter:t,subtree:!0});const i={subscribe:t=>(s.add(t),()=>{s.delete(t),0===s.size&&(n.disconnect(),r[e]=void 0)})};return r[e]=i,i}(e);return s((e=>{const s=e.some((e=>function(t,e){let o=t;for(;o;){if(o===e)return!0;if(!o.parentNode)return!1;o=o.parentNode instanceof ShadowRoot?o.parentNode.host:o.parentNode}return!1}(t,e.target)));s&&o()}))}var r={};function i(t,e){let o=t;for(;o;){const t=o.closest?.(e);if(t)return t;const s=o.getRootNode?.();if(s===globalThis.document)return null;o=s.host}return null}function c(t){return a(t,"dir","ltr")}function a(t,e,o){const s=i(t,`[${e}]`);return s?.getAttribute(e)??o}function l(t,e,...o){try{return t?.call(e,...o)}catch(e){console.error(e,t)}}async function h(t,e,...o){try{const s=t?.call(e,...o);return s instanceof Promise?await s:s}catch(e){console.error(e,t)}}function d(t){let e="";for(let o=0;o<t;o++)e+=(65536*(1+Math.random())|0).toString(16).substring(1);return e}function u(){return[d(2),d(1),d(1),d(1),d(3)].join("-")}var p=new Set(["ar","bg","bs","ca","cs","da","de","el","en","es","et","fi","fr","he","hr","hu","id","it","ja","ko","lt","lv","nl","nb","no","pl","pt-BR","pt-PT","ro","ru","sk","sl","sr","sv","th","tr","uk","vi","zh-CN","zh-HK","zh-TW"]),f="en",y={pt:"pt-PT",nb:"no",zh:"zh-CN"};async function g(t,e,o=""){const s=`${e}/${o}`,n=`${s}${t}.json`;return m[n]??(m[n]=_(t,s)),await m[n]}var m={};async function _(t,e){const o=`${e}${t}.json`;try{const t=await fetch(o);if(t.ok)return await t.json()}catch(t){return console.error(t),{}}return t===f?{}:await _(f,e)}function b(t){const e=a(t,"lang",globalThis.navigator?.language||f);return{lang:e,t9nLocale:v(e)}}function v(t){const[e,o]=t.split("-"),s=e.toLowerCase();let n=s;return o&&(n=`${s}-${o.toUpperCase()}`),n=y[n]??n,p.has(n)?n:o?v(s):f}function k(t,e,o,s){let r;const i=()=>{(async function(t,e,o=t.tagName.toLowerCase().split("-").slice(1).join("-")){const{lang:s,t9nLocale:n}=b(t),r=`${e}/${o}/t9n`,i="messages.",c=null===o?{}:await g(n,r,i);return{lang:s,t9nLocale:n,t9nStrings:c}})(t,e(),s).then((t=>{r?.lang===t.lang&&r.t9nLocale===t.t9nLocale&&r.t9nStrings===t.t9nStrings||o(t),r=t})).catch(console.error)};return queueMicrotask(i),n(t,["lang"],i)}var L=4e3,C=2e3,x=4;function w(t){return void 0!==t}var D,E=Symbol.for("controller");function U(t){D!==t&&(D=t,queueMicrotask((()=>{D===t&&(D=void 0)})))}function P(t){return D}var j,S=[];function T(t){if(void 0===t)return void(S=[]);const e=S.indexOf(t);S=-1===e?[...S,t]:S.slice(0,e+1),queueMicrotask((()=>{S=[]}))}function O(){return S}var W,$=async(t,e)=>{const o=R(t);if(void 0===o)return t;if(await o.ready,"function"==typeof e){const t=o.watchExports((o=>e(o,t)))}return o.exports},M=async t=>{const e=R(t);return await e.ready,e},R=t=>{const e=P().manager.internals.resolveExports(t);if(void 0!==e)return e;if((t=>"object"==typeof t&&null!==t&&(E in t||"hostConnected"in t||"hostDisconnected"in t||"hostUpdate"in t||"hostUpdated"in t))(t))return t;const o=function(){const t=j;return j=void 0,t}();return void 0!==o?o:void 0},A={setter:!1,getter:!1,readOnly:!1},q=new WeakMap;W=E;var N=class{constructor(t){this._callbacks={hostConnected:[],hostDisconnected:[],hostLoad:[],hostLoaded:[],hostUpdate:[],hostUpdated:[],hostDestroy:[],hostLifecycle:[]},this._ready=new s,this._lifecycleCleanups=[],this.connectedCalled=!1,this._loadCalled=!1,this.loadedCalled=!1,this[W]=!0,this.ready=this._ready.promise,this._exports=I(this),this._exportWatchers=new Set;const e=t??P();this.component=e,this.component.addController(this);void 0===this.component.manager||(T(this),queueMicrotask((()=>this.catchUpLifecycle())))}catchUpLifecycle(){const{manager:t}=this.component;!t.connectedCalled||this.connectedCalled||this.triggerConnected();!t._loadCalled||this.triggerLoad().then((()=>{!t.loadedCalled||this.triggerLoaded()})).catch(console.error)}get exports(){return this._exports}set exports(t){const e=this._exports;e!==t&&(this._exports=t,this._exportWatchers.forEach(l),this.connectedCalled&&!1!==this.assignedProperty&&this.component.requestUpdate(this.assignedProperty,e)),this._ready.resolve(t)}setProvisionalExports(t,e=!0){this._exports=e?I(t):t,this._exportWatchers.forEach(l)}watchExports(t){const e=()=>t(this._exports);return this._exportWatchers.add(e),()=>{this._exportWatchers.delete(e)}}get use(){return U(this.component),$}get useRef(){return U(this.component),M}get useRefSync(){return U(this.component),R}controllerRemoved(){this.component.el.isConnected&&this.triggerDisconnected(),this.triggerDestroy()}onConnected(t){this._callbacks.hostConnected.push(t)}onDisconnected(t){this._callbacks.hostDisconnected.push(t)}onLoad(t){this._callbacks.hostLoad.push(t)}onLoaded(t){this._callbacks.hostLoaded.push(t)}onUpdate(t){this._callbacks.hostUpdate.push(t)}onUpdated(t){this._callbacks.hostUpdated.push(t)}onDestroy(t){this._callbacks.hostDestroy.push(t)}onLifecycle(t){this._callbacks.hostLifecycle.push(t),this.connectedCalled&&this.component.el.isConnected&&this._callLifecycle(t)}triggerConnected(){const t=this;t.hostConnected&&l(t.hostConnected,t),this._callbacks.hostConnected.forEach(l),this.triggerLifecycle(),this.connectedCalled=!0}triggerDisconnected(){const t=this;t.hostDisconnected&&l(t.hostDisconnected,t),this._callbacks.hostDisconnected.forEach(l),this._lifecycleCleanups.forEach(l),this._lifecycleCleanups=[]}async triggerLoad(){if(this._loadCalled)return;this._loadCalled=!0;const t=this;t.hostLoad&&await h(t.hostLoad,t),this._callbacks.hostLoad.length>0&&await Promise.allSettled(this._callbacks.hostLoad.map(h)),this._ready.resolve(this._exports)}triggerLoaded(){if(this.loadedCalled)return;const t=this;t.hostLoaded&&l(t.hostLoaded,t),this._callbacks.hostLoaded.forEach(l),this.loadedCalled=!0}triggerUpdate(t){const e=this;e.hostUpdate&&l(e.hostUpdate,e,t),this._callbacks.hostUpdate.forEach(z,t)}triggerUpdated(t){const e=this;e.hostUpdated&&l(e.hostUpdated,e,t),this._callbacks.hostUpdated.forEach(z,t)}triggerDestroy(){const t=this;t.hostDestroy&&l(t.hostDestroy,t),this._callbacks.hostDestroy.forEach(l)}triggerLifecycle(){const t=this;t.hostLifecycle&&this._callLifecycle((()=>t.hostLifecycle())),this._callbacks.hostLifecycle.forEach(this._callLifecycle,this)}_callLifecycle(t){U(this.component);const e=l(t);(Array.isArray(e)?e:[e]).forEach((t=>{"function"==typeof t?this._lifecycleCleanups.push(t):"object"==typeof t&&"function"==typeof t.remove&&this._lifecycleCleanups.push(t.remove)}))}};function z(t){l(t,void 0,this)}var V=N;function I(t){if("object"!=typeof t&&"function"!=typeof t||null===t)return t;const e=new Proxy(t,{get(t,o,s){if(!F.has(o)||!(o in t)||t[o]!==e)return o in t||o in Promise.prototype||"symbol"==typeof o?"function"==typeof t?t[o]:Reflect.get(t,o,s):void 0},set:(t,e,o,s)=>Reflect.set(t,e,o,s)});return e}var F=new Set(["exports","_exports"]);var G=void 0;function B(){Array.from(G?.entries()??[]).forEach((([t,{callbacks:e}])=>{const o=Object.keys(t);e.forEach((t=>t(o)))})),G=void 0}function H(t,e,o){var s;const n=e,r=t.manager.internals;(s=r.allWatchers)[n]??(s[n]=[]);const i=r.allWatchers[n],c=o,a=(t,e,o)=>l(c,null,t,e,o);return i.push(a),()=>{const t=i.indexOf(a);-1!==t&&i.splice(t,1)}}var K=class{constructor(t){this.enabledWatchers={},this.allWatchers={},this.enableReadonly=()=>{if(this.enableReadonly=void 0,!this.component.manager.isLit)return;const t=this.component.manager.internals;Object.entries(t.members).forEach((([e,[o]])=>{var s;2048&o&&((s=t.setters)[e]??(s[e]=[]),t.setters[e].push(t.readonlySetter))}))},this.trackedValue=X,this.keyTrackers=[],this.getters={},this.setters={},this.accessorGetter={},this.accessorSetter={},this._exports=new WeakMap,this.readonlySetter=(t,e,o)=>{if(A.readOnly)return t;throw new Error(`Cannot assign to read-only property "${o}" of ${this.component.el.tagName.toLowerCase()}. Trying to assign "${String(t)}"`)},this.component=t}firePropTrackers(t,e){const o=this.keyTrackers;this.trackedValue=X,this.keyTrackers=[],o.forEach((o=>o(t,e)))}getSetProxy(t){const e=this.component,o=e.constructor.prototype;if(this._getSetProxy(o,t,"class"),e.manager.isLit)return;const s=e.el.constructor.prototype;o!==s&&this._getSetProxy(s,t,"html")}_getSetProxy(t,e,o){const s=((t,e)=>t.manager.internals.members?.[e]?.[0])(this.component,e);let n;do{n=Object.getOwnPropertyDescriptor(t,e)}while(!n&&(t=Object.getPrototypeOf(t)));if(!n)return;const r=n.get,i=n.set,c=Q in r,a=Q in i;if(c&&a)return;const l=!c,h=!a,d=l?function(){let t=r.call(this);const o=q.get(this);if(void 0===o)return t;const s=o.manager.internals;t=s.accessorGetter[e](t,e);const n=s.getters[e]??J;for(let o=0;o<n.length;o++)t=n[o](t,e);return t}:r,u=h?function(t){const o=r.call(this),n=q.get(this);if(void 0===n)return void i.call(this,t);let c=n.manager.isLit?t??void 0:function(t,e=8){return null==t||"object"==typeof t||"function"==typeof t?t:4&e?"false"!==t&&(""===t||!!t):2&e?Number.parseFloat(t):1&e?String(t):t}(t,s);const a=n.manager.internals;if(c===o)i.call(this,c);else{const t=a.setters[e]??J;for(let s=0;s<t.length&&(c=t[s](c,o,e),c!==o);s++);c=a.accessorSetter[e](c,o,e),i.call(this,c),c!==o&&a.enabledWatchers[e]?.forEach((t=>t(c,o,e)))}a.keyTrackers.length>0&&a?.firePropTrackers(e,t)}:i;l&&(d[Q]=!0),h&&(u[Q]=!0),Object.defineProperty(t,e,{...n,get:d,set:u})}markExports(t,e){("object"==typeof e&&null!==e||"function"==typeof e)&&this._exports.set(e,t)}resolveExports(t){return"object"==typeof t&&null!==t||"function"==typeof t?this._exports.get(t):void 0}},J=[],Q=Symbol(),X=Symbol();function Y(t=[P(),...O()],e,o){const s=Array.isArray(t)?t:[t];let n=s.length+1;const r=t=>{n-=1,void 0!==t&&(n=Math.min(n,0)),0===n&&e(t)};s.forEach((t=>function(t,e,o){const s=Object.keys(t),n=s.length;void 0===G&&queueMicrotask(B),G??(G=new Map);let r=G.get(t);return void 0===r&&(r={callbacks:[],keyCount:n},G.set(t,r)),r.keyCount!==n&&(r.callbacks.forEach((t=>t(s))),r.callbacks=[],r.keyCount=n),r.callbacks.push((s=>{const r=t=>l(e,null,t),i=s[n];void 0===i?r(void 0):t[i]===o?r(i):r(void 0)})),o}(t,(e=>r(void 0===e?void 0:{key:e,host:t,isReactive:!1})),o)));const i=s.find((t=>"manager"in t&&"object"==typeof t.manager&&t.manager.component===t));return i&&function(t,e,o){const s=t.manager.internals;s.trackedValue!==X&&s.trackedValue!==o&&s.firePropTrackers(void 0,void 0),0===s.keyTrackers.length&&queueMicrotask((()=>s.firePropTrackers(void 0,void 0))),s.trackedValue=o,s.keyTrackers.push(((t,s)=>l(e,void 0,o===s?t:void 0)))}(i,(t=>r(void 0===t?void 0:{key:t,host:i,isReactive:!0})),o),o}var Z=(t,e)=>new tt(t,e),tt=class extends V{constructor(t,e){const o="addController"in t,n=new Set;const r=t;if(r.addController=function(e){n.add(e),!(E in e)&&t.renderRoot&&t.el.isConnected&&e.hostConnected?.()},r.removeController=function(t){n.delete(t),t.controllerRemoved?.()},!o){const o=e??t.constructor.__forceUpdate;r.requestUpdate=()=>o(t)}super(t),this.internals=new K(this.component),this.destroyed=!1,this._updatePromise=new s,this._originalLifecycles={},this.isLit=o,this.component.manager=this,function(t,e){if(e){const e=t.constructor.elementProperties;t.manager.internals.members=Object.fromEntries(Array.from(e,(([t,e])=>e.noAccessor?void 0:[t,[(e.readOnly?2048:0)|(e.state?32:16)]])).filter(w))}else{const e=t.constructor,o=e.__registerControllers?.(t)??void 0;if(e.__registerControllers=void 0,"object"!=typeof o)throw new Error("Failed to retrieve component meta");t.manager.internals.members=Object.fromEntries(Object.entries(o).filter((([t,[e]])=>!!(63&e))))}}(t,o),this._controllers=n,this.exports=void 0,this.hasDestroy=et in this.component&&"function"==typeof this.component.destroy,this._bindLifecycleMethods();const i=this.internals;Object.keys(i.members).forEach((t=>{i.accessorGetter[t]=st,i.accessorSetter[t]=st,i.getSetProxy(t)})),o?this.internals.enabledWatchers=this.internals.allWatchers:Object.defineProperty(t,"updateComplete",{get:async()=>await this._updatePromise.promise}),queueMicrotask(i.enableReadonly),U(t),q.set(t.el,t),q.set(t,t)}_bindLifecycleMethods(){const t=this.component,e=this.isLit,o=t.el===t;this._originalLifecycles={_connectedCallback:e||o?void 0:t.connectedCallback,_disconnectedCallback:e||o?void 0:t.disconnectedCallback,_load:e?t.load:t.componentWillLoad,_loaded:e?t.loaded:t.componentDidLoad,_willUpdate:e?void 0:t.componentWillUpdate,_updated:e?void 0:t.componentDidUpdate,_destroy:t.destroy};const s=this._connectedCallback.bind(this),n=this._disconnectedCallback.bind(this),r=this._update.bind(this),i=this._updated.bind(this);e?t.constructor.prototype.addController.call(t,{hostConnected:s,hostDisconnected:n,hostUpdate:r,hostUpdated:i}):(t.connectedCallback=s,t.disconnectedCallback=n,t.componentWillLoad=this._load.bind(this),t.componentDidLoad=this._loaded.bind(this),t.componentWillUpdate=r,t.componentDidUpdate=i),this.hasDestroy&&(t.destroy=this.destroy.bind(this))}_connectedCallback(){if(this.destroyed){const t=this.component.el.tagName.toLowerCase();throw this.component.el.remove(),new Error(`The ${t} component has already been destroyed. It cannot be used again. If you meant to disconnect and reconnect a component without automatic destroy, set the ${et} prop.`)}void 0!==this._autoDestroyTimeout&&clearTimeout(this._autoDestroyTimeout);const t=this.internals;t.enabledWatchers=t.allWatchers,B(),t.enableReadonly?.(),this._controllers.forEach(nt),this._originalLifecycles._connectedCallback?.call(this.component)}_disconnectedCallback(){this.destroyed||(this._controllers.forEach(rt),this._originalLifecycles._disconnectedCallback?.call(this.component),this.hasDestroy&&this._setAutoDestroyTimeout())}async _load(){await Promise.allSettled(Array.from(this._controllers,it)),await(this._originalLifecycles._load?.call(this.component)),this.hasDestroy&&H(this.component,et,(()=>this._setAutoDestroyTimeout()))}_loaded(){this._controllers.forEach(ct),this._originalLifecycles._loaded?.call(this.component)}_update(){const t=this.component;return this._controllers.forEach(at,t.$changes),this._originalLifecycles._willUpdate?.call(this.component)}_updated(){const t=this.component;if(this._controllers.forEach(lt,t.$changes),this._originalLifecycles._updated?.call(this.component),this.isLit)t.$changes=new Map;else{const t=this._updatePromise;this._updatePromise=new s,t.resolve(!0)}}async destroy(){if(!this.destroyed){if(this.component.el.isConnected){this.hasDestroy=!1;try{this.component.el.remove()}finally{this.hasDestroy=!0}}this._autoDestroyTimeout=void 0,this.destroyed=!0,this._controllers.forEach(ht),this._controllers.clear(),await(this._originalLifecycles._destroy?.call(this.component))}}_setAutoDestroyTimeout(){if(void 0!==this._autoDestroyTimeout&&clearTimeout(this._autoDestroyTimeout),!this.component.el.isConnected&&!this.component.autoDestroyDisabled){const t=()=>{this.destroy().catch(console.error)};this._autoDestroyTimeout=function(t,e){const o=e>L?C:e/x;let s=0;const n=setInterval((()=>{s+=o,s>=e&&(clearInterval(n),t())}),o);return n}(t,ot)}}},et="autoDestroyDisabled",ot=1e3,st=t=>t;function nt(t){"triggerConnected"in t?t.triggerConnected():l(t.hostConnected,t)}function rt(t){"triggerDisconnected"in t?t.triggerDisconnected():l(t.hostDisconnected,t)}async function it(t){"triggerLoad"in t?await t.triggerLoad():await h(t.hostLoad,t)}function ct(t){"triggerLoaded"in t?t.triggerLoaded():l(t.hostLoaded,t)}function at(t){"triggerUpdate"in t?t.triggerUpdate(this):l(t.hostUpdate,t,this)}function lt(t){"triggerUpdated"in t?t.triggerUpdated(this):l(t.hostUpdated,t,this)}function ht(t){"triggerDestroy"in t?t.triggerDestroy():l(t.hostDestroy,t)}var dt,ut=(dt=class extends N{constructor(t,e){super(t);const o=this.exports;try{U(this.component);const t=e(this.component,this),s=this.exports!==o;if(t instanceof Promise){s||this.setProvisionalExports(t);const e=t.then((t=>{this.exports=t,super.catchUpLifecycle()})).catch((t=>{this._ready.reject(t),console.error(t)}));this.onLoad((async()=>await e))}else s&&void 0===t||(this.exports=t),queueMicrotask((()=>super.catchUpLifecycle()))}catch(t){this._ready.reject(t),console.error(t)}}catchUpLifecycle(){}},(...t)=>{const e=O(),o=new dt(...t),s=o.exports;T(e.at(-1));const n=o.component.manager.internals;var r;return n.markExports(o,s),o.watchExports((t=>n.markExports(o,t))),j!==(r=o)&&(j=r,queueMicrotask((()=>{j===r&&(j=void 0)}))),Y([o.component,...e].reverse(),(t=>void 0===t?void 0:function(t,{host:e,key:o,isReactive:s},n){const r=e,i=r[o]!==t.exports,c=r[o]!==n,a=n!==t.exports;i&&!c&&a&&(r[o]=t.exports);const l=e===t.component;if(l){if(s){const e=t.component.manager.internals;c&&e.markExports(t,r[o]),H(t.component,o,(o=>{o!==t.exports&&e.markExports(t,o)}))}t.assignedProperty=s?void 0:o}t.watchExports((()=>{if(r[o]===t.exports)return;const e=t.component.manager,s=e.internals.setters[o]?.includes(e.internals.readonlySetter);s?function(t){A.readOnly=!0;try{return t()}finally{A.readOnly=!1}}((()=>{r[o]=t.exports})):r[o]=t.exports}))}(o,t,s)),s)}),pt=t=>(e={})=>ut(void 0,((o,s)=>{const n=b(o.el),r={_lang:n.lang,_t9nLocale:n.t9nLocale,_loading:!0},i=o;function c(t){const e=s.exports,o=e._original??e,n=ft(o,t);t&&(n._original=o),s.exports=n}return s.onLifecycle((()=>k(o.el,(()=>t("./assets")),(({t9nLocale:t,t9nStrings:e,lang:n})=>{const r={...e,_lang:n,_t9nLocale:t,_loading:!1};s.exports=r;const a=e.componentLabel;"string"==typeof a&&"label"in o&&null==o.label&&(o.label??(o.label=a)),c(i.messageOverrides)}),e.name))),"messageOverrides"in i&&s.onLifecycle((()=>H(i,"messageOverrides",c))),e.blocking?(s.setProvisionalExports(r,!1),s.ready):r}));function ft(t,e){if(!e)return t;const o={...t};return Object.entries(e).forEach((([e,s])=>{o[e]="object"==typeof s?ft(t[e],s):s??t[e]})),o}}}]);