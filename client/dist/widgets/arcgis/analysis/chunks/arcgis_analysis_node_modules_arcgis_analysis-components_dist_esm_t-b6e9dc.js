"use strict";(self.webpackChunkexb_client=self.webpackChunkexb_client||[]).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_analysis-components_dist_esm_t-b6e9dc"],{87192:(e,t,i)=>{i.d(t,{B:()=>R,D:()=>D,E:()=>Z,G:()=>N,H:()=>_,N:()=>E,S:()=>G,a:()=>r,b:()=>J,c:()=>c,d:()=>S,e:()=>C,f:()=>u,g:()=>se,h:()=>l,i:()=>j,j:()=>re,k:()=>b,l:()=>$,m:()=>v,n:()=>o,o:()=>a,s:()=>ie});var s=i(22069),n=i(46033);const r={And:"and",Or:"or",Default:""},a=["Meters","Kilometers","Feet","Yards","Miles"],o={Intersects:"intersects",NotIntersects:"notIntersects",WithinDistance:"withinDistance",NotWithinDistance:"notWithinDistance",Contains:"contains",NotContains:"notContains",Within:"within",NotWithin:"notWithin",Nearest:"nearest"};function l(e){return"small-integer"===e||"integer"===e||"big-integer"===e||"long"===e||"oid"===e}function u(e){return"single"===e||"double"===e}function c(e,t){if(!1===e)throw new Error(t)}let p=0;function h(){return p+=1,`${p}`}const d=86399e3;function y(e){const t=function(e){return new Date(e.toDateString())}(e),i=function(e){return new Date(e.getTime()+d)}(e);return[t,i]}function f(e){const t=e[0],i=(s=e[1],new Date(s.getTime()-d));var s;return Math.abs(i.getTime()-t.getTime())<1e3}const _={errorNotice:"error-notice"},g="parsingPreviousQueryError",m="queryFieldsError",w=Object.freeze({equal:(e,t)=>`${e} = ${t}`,not_equal:(e,t)=>`${e} <> ${t}`,is_in:(e,t)=>`${e} IN(${t.join(", ")})`,is_not_in:(e,t)=>`${e} NOT IN(${t.join(", ")})`,less:(e,t)=>`${e} < ${t}`,less_or_equal:(e,t)=>`${e} <= ${t}`,greater:(e,t)=>`${e} > ${t}`,greater_or_equal:(e,t)=>`${e} >= ${t}`,between:(e,t)=>`${e} BETWEEN ${t.join(" AND ")}`,not_between:(e,t)=>`${e} NOT BETWEEN ${t.join(" AND ")}`,contains:(e,t)=>`${e} LIKE '%${t.slice(1,-1)}%'`,not_contains:(e,t)=>`${e} NOT LIKE '%${t.slice(1,-1)}%'`,begins_with:(e,t)=>`${e} LIKE '${t.slice(1,-1)}%'`,not_begins_with:(e,t)=>`${e} NOT LIKE '${t.slice(1,-1)}%'`,ends_with:(e,t)=>`${e} LIKE '%${t.slice(1,-1)}'`,not_ends_with:(e,t)=>`${e} NOT LIKE '%${t.slice(1,-1)}'`,is_empty:(e,t)=>`${e} = ''`,is_not_empty:(e,t)=>`${e} <> ''`,is_blank:(e,t)=>`${e} IS Null`,is_not_blank:(e,t)=>`${e} IS NOT Null`,is_on:(e,t)=>`${e} BETWEEN ${t}`,is_not_on:(e,t)=>`${e} NOT BETWEEN ${t}`,is_before:(e,t)=>`${e} < ${t}`,is_after:(e,t)=>`${e} > ${t}`,in_the_last:(e,t)=>`${e} BETWEEN ${t}`,this_year:(e,t)=>`EXTRACT(YEAR FROM ${e}) = EXTRACT(YEAR FROM CURRENT_DATE)`,this_month:(e,t)=>`(EXTRACT(MONTH FROM ${e}) = EXTRACT(MONTH FROM CURRENT_DATE) AND EXTRACT(YEAR FROM ${e}) = EXTRACT(YEAR FROM CURRENT_DATE))`,this_day:(e,t)=>`(EXTRACT(DAY FROM ${e}) = EXTRACT(DAY FROM CURRENT_DATE) AND EXTRACT(MONTH FROM ${e}) = EXTRACT(MONTH FROM CURRENT_DATE) AND EXTRACT(YEAR FROM ${e}) = EXTRACT(YEAR FROM CURRENT_DATE))`,not_in_the_last:(e,t)=>`${e} NOT BETWEEN ${t}`,is_true:(e,t)=>`${e} IS TRUE`,is_false:(e,t)=>`${e} IS FALSE`}),T={"<":"less","<=":"less_or_equal",">":"greater",">=":"greater_or_equal","=":"equal","<>":"not_equal",IN:"is_in","NOT IN":"is_not_in",BETWEEN:"between",NOTBETWEEN:"not_between"},E=["between","not_between","equal","not_equal","is_in","is_not_in","greater","greater_or_equal","less","less_or_equal","is_blank","is_not_blank"],v=["equal","not_equal","is_in","is_not_in","contains","not_contains","begins_with","not_begins_with","ends_with","not_ends_with","is_blank","is_not_blank","is_empty","is_not_empty"],$=["between","not_between","is_on","is_not_on","is_before","is_after","in_the_last","not_in_the_last","is_blank","is_not_blank","this_year","this_month","this_day"],b=["between","not_between","is_on","is_not_on","is_before","is_after","in_the_last","not_in_the_last","is_blank","is_not_blank","this_year","this_month","this_day"],N=["is_blank","is_not_blank"],R=["is_blank","is_not_blank","is_true","is_false"],I=["between","not_between"],x=["is_in","is_not_in"],L=["in_the_last","not_in_the_last"],D={date:["minute","hour","day","week"],"date-only":["day","week"]},A=["is_blank","is_not_blank","is_empty","is_not_empty","is_true","is_false","this_year","this_month","this_day"];function S(e){return I.includes(e)}function O(e){return x.includes(e)}function C(e){return A.includes(e)}function k(e,t){return t?`"${e}"`:e}function F(e,t){switch(t){case"integer":case"small-integer":case"big-integer":case"long":case"oid":return null==e?"0":("number"!=typeof e&&(e=parseInt(e)),"number"==typeof e&&isNaN(e)?"0":`${e}`);case"double":case"single":return null==e?"0.0":("number"!=typeof e&&(e=parseFloat(e)),"number"==typeof e&&isNaN(e)?"0.0":`${e}`);case"date":const i=e instanceof Date?e:void 0;return void 0!==i?`timestamp '${function(e){if(void 0===e)return"";const t=`${e.getUTCFullYear()}`;let i=`${e.getUTCMonth()+1}`;1===i.length&&(i=`0${i}`);let s=`${e.getUTCDate()}`;1===s.length&&(s=`0${s}`);let n=`${e.getUTCHours()}`;1===n.length&&(n=`0${n}`);let r=`${e.getUTCMinutes()}`;1===r.length&&(r=`0${r}`);let a=`${e.getUTCSeconds()}`;return 1===a.length&&(a=`0${a}`),`${t}-${i}-${s} ${n}:${r}:${a}`}(i)}'`:"''";case"date-only":return void 0!==e?`date '${e}'`:"''";case"string":const s=e;return`'${null==s?"":s.replace(/'/g,"''")}'`;case"boolean":case"geometry":return"";default:throw new Error(`Unsupported data type: ${t}`)}}function M(e){switch(e.type){case"string":case"number":case"date":case"boolean":return e.value;case"null":return null;case"timestamp":return function(e){const t=new Date(e);return new Date(t.getTime()-6e4*t.getTimezoneOffset())}(e.value);default:throw new Error(`Invalid expression: unsupported node value: ${e.type}.`)}}function q(e){if("binary-expression"!==e.type||"="!==e.operator||"function"!==e.left.type||"extract"!==e.left.name||"expression-list"!==e.left.args.type||"function"!==e.right.type||"extract"!==e.right.name||"expression-list"!==e.right.args.type)return;const t=[...e.left.args.value,...e.right.args.value];let i,s,n;if("string"===t[0].type)switch(t[0].value.toLowerCase()){case"year":i="this_year";break;case"month":i="this_month";break;case"day":i="this_day"}if(void 0===i)throw new Error("Unsupported date part for date part query.");for(const e of t)"column-reference"===e.type?s=e.column:"current-time"===e.type&&(n=e);if(void 0===s)throw new Error("No column reference found for date part query.");if(void 0===n)throw new Error("No comparison with current time found for date part query.");return{field:s,operator:i}}function U(e){if("binary-expression"!==e.type)return;let t;if("="===e.operator){if(t=q(e),"this_month"===t?.operator)throw new Error("'This month' queries must include a month and year comparison.");if("this_day"===t?.operator)throw new Error("'This day' queries must include a day, month, and year comparison.")}else if("AND"===e.operator)if("binary-expression"===e.left.type&&"AND"===e.left.operator){const i=q(e.left.left),s=q(e.left.right),n=q(e.right),r=[i?.operator,s?.operator,n?.operator],a=new Set([i?.field,s?.field,n?.field]);if(r.includes("this_day")&&r.includes("this_month")&&r.includes("this_year")){if(1!==a.size)throw new Error("'This day' queries must use the same field for day, month, and year comparisons.");t={field:i.field,operator:"this_day"}}}else{const i=q(e.left),s=q(e.right),n=[i?.operator,s?.operator],r=new Set([i?.field,s?.field]);if(n.includes("this_month")&&n.includes("this_year")){if(1!==r.size)throw new Error("'This month' queries must use the same field for month and year comparisons.");t={field:i.field,operator:"this_month"}}}return t}var Q;function W(e){return null==e}function K(e){let t=!0;return(W(e)||""===e||"number"==typeof e&&isNaN(e))&&(t=!1),t}class P{constructor(e,t,i,s,n){this.field=e,this.dataType=t,this.value=i,this.operator=s,this.id=n??h()}}class V extends P{constructor(){super(...arguments),this.type="value"}validate(){return C(this.operator)||K(this.value)}toSQL(e){let t;if("date"===this.dataType)t=this.toSQLForDate(this.value,this.operator,e);else if("date-only"===this.dataType)t=this.toSQLForDateOnly(this.value,this.operator,e);else{const i=k(this.field,!0===e?.useDelimitedIdentifiers),s=F(this.value,this.dataType);t=w[this.operator](i,s)}return t}toSQLForDate(e,t,i){const s=k(this.field,!0===i?.useDelimitedIdentifiers);switch(t){case"is_on":case"is_not_on":const i=void 0!==e?y(e).map((e=>F(e,"date"))):["''","''"];return w[t](s,`${i[0]} AND ${i[1]}`);default:const n=F(e,"date");return w[t](s,n)}}toSQLForDateOnly(e,t,i){const s=k(this.field,!0===i?.useDelimitedIdentifiers),n=F(e,this.dataType);switch(t){case"is_on":return w.equal(s,n);case"is_not_on":return w.not_equal(s,n);default:return w[t](s,n)}}}class X extends P{constructor(){super(...arguments),this.type="multi-value"}get validValues(){return this.value.filter(K)}validate(){return this.validValues.length>0}toSQL(e){const t=k(this.field,!0===e?.useDelimitedIdentifiers),i=this.validValues.map((e=>F(e,this.dataType)));return w[this.operator](t,i)}}class Y extends P{constructor(){super(...arguments),this.type="range"}validate(){return K(this.value[0])&&K(this.value[1])}toSQL(e){const t=k(this.field,!0===e?.useDelimitedIdentifiers),i=F(this.value[0],this.dataType),s=F(this.value[1],this.dataType);return w[this.operator](t,[i,s])}}class B extends P{constructor(){super(...arguments),this.type="distance"}validate(){return K(this.value.distance)&&K(this.value.unit)}toSQL(e){if("date"!==this.dataType&&"date-only"!==this.dataType)throw new Error(`Unsupported data type for 'Distance' expressions: ${this.dataType}`);const t=k(this.field,!0===e?.useDelimitedIdentifiers),i=function(e,t,i){const s="date-only"===i?"CURRENT_DATE":"CURRENT_TIMESTAMP";switch(t){case"minute":return`CURRENT_TIMESTAMP - INTERVAL '${e}' MINUTE AND CURRENT_TIMESTAMP`;case"hour":return`CURRENT_TIMESTAMP - INTERVAL '${e}' HOUR AND CURRENT_TIMESTAMP`;case"day":return`${s} - INTERVAL '${e}' DAY AND ${s}`;case"week":return`${s} - INTERVAL '${7*e}' DAY AND ${s}`;default:throw new Error(`Unsupported unit for 'In the last' queries: ${t}`)}}(this.value.distance??0,this.value.unit??"hour",this.dataType);return w[this.operator](t,i)}}class G{constructor(e,t,i,s){this.layer=e,this.selectingLayer=t,this.spatialRelationship=i,this.spatialRelationshipParams=s}get isDistanceRelationship(){return"withinDistance"===this.spatialRelationship||"notWithinDistance"===this.spatialRelationship}validate(){let e=void 0!==this.selectingLayer&&void 0!==this.spatialRelationship;if(this.isDistanceRelationship){const{distance:t,units:i}=this.spatialRelationshipParams??{};e=e&&K(t)&&K(i)}return e}changeSelectingLayer(e){return new G(this.layer,e,this.spatialRelationship,this.spatialRelationshipParams)}static getValidLayersForRelationships(e,t,i){const s=new Map;return i.forEach((i=>{let n=this.filterLayersBasedOnGeometryType(e,t,i);n=this.getValidSelectingLayers(e,n??[]),s.set(i,n)})),s}static filterLayersBasedOnGeometryType(e,t,i){const s=new Map;t.forEach((e=>{if(s.has(e.geometryType)){s.get(e.geometryType).push(e)}else s.set(e.geometryType,[e])}));const n=e.geometryType,r=s.get("polygon")??[],a=s.get("polyline")??[],o=s.get("point")??[],l=s.get("multipoint")??[];let u=[];return u="contains"===i||"notContains"===i?"polygon"===n?[...o,...a,...r,...l]:"polyline"===n?[...o,...a,...l]:"point"===n||"multipoint"===n?[...o,...l]:[]:"within"===i||"notWithin"===i?"point"===n||"multipoint"===n?[...o,...a,...r,...l]:"polyline"===n?[...r,...a]:"polygon"===n?r:[]:t,u}static getValidSelectingLayers(e,t){return t.filter((t=>e.id!==t.id))}changeSpatialRelationship(e){const t=new G(this.layer,this.selectingLayer,e);return t.isDistanceRelationship&&(t.spatialRelationshipParams={distance:this.spatialRelationshipParams?.distance,units:this.spatialRelationshipParams?.units??a[0]}),t}changeSpatialRelationshipDistance(e){const t={...this.spatialRelationshipParams,distance:e};return new G(this.layer,this.selectingLayer,this.spatialRelationship,t)}changeSpatialRelationshipUnit(e){const t={...this.spatialRelationshipParams,units:e};return new G(this.layer,this.selectingLayer,this.spatialRelationship,t)}}function j(e,t,i){if(void 0===e)return!1;const s=t?.allowGeometryFields??!1,n=[i?.geometryFieldsInfo?.shapeAreaField,i?.geometryFieldsInfo?.shapeLengthField].includes(e.name)&&!1===s;if(!0===t?.hideObjectIdField&&e.name===i?.objectIdField||!0===n)return!1;switch(e.type){case"string":case"small-integer":case"integer":case"single":case"double":case"long":case"big-integer":case"date":case"date-only":case"geometry":case"oid":return!0;default:return!1}}function H(e,t){let i;return W(e.description)||(e.description===t?.booleanFieldDescription?i="boolean":!0===t?.geometryFieldDescriptions?.includes(e.description)&&(i="geometry")),i}function z(e){let t="value";return S(e)?t="range":O(e)?t="multi-value":function(e){return L.includes(e)}(e)&&(t="distance"),t}class J{constructor(e){this.expression=e}changeOperator(e){const{field:t,dataType:i,id:s}=this.expression,n=Q.create({field:t,dataType:i,operator:e,id:s});return z(e)===this.expression.type&&(n.value=this.expression.value),n}changeField(e,t){if(!j(e,t))throw new Error(`Unsupported field type '${e.type}' for '${e.name}'`);const i=H(e,t)??e.type;return Q.create({field:e.name,dataType:i,id:this.expression.id})}changeValue(e){return Q.create({field:this.expression.field,dataType:this.expression.dataType,operator:this.expression.operator,value:e,id:this.expression.id})}static create({field:e,dataType:t,operator:i,id:s,value:n}){let r,a,o;switch(t){case"string":r="equal",a=v;break;case"small-integer":case"integer":case"big-integer":case"single":case"double":case"long":case"oid":r="equal",a=E;break;case"date":r="is_on",a=$;break;case"date-only":r="is_on",a=b;break;case"geometry":r="is_blank",a=N;break;case"boolean":r="is_true",a=R;break;default:throw new Error(`Data type not supported: ${t}`)}if(void 0!==i&&!a.includes(i))throw new Error(`Invalid operator '${i}' for type '${e}'`);const l=i??r;switch(z(l)){case"value":o=new V(e,t,n,l,s);break;case"multi-value":o=new X(e,t,n??[],l,s);break;case"range":o=new Y(e,t,n??[void 0,void 0],l,s);break;case"distance":o=new B(e,t,n??{unit:"day"},l,s)}return o}static createDefaultForLayer(e,t){const i=e.fields.filter((i=>j(i,t,e)));if(!(i.length<1)){const e=i[0],s=H(e,t)??e.type;return Q.create({field:e.name,dataType:s})}}}Q=J,J.fromSQL=async(e,t,i)=>{const n=await(0,s.au)(e,t);return Q.fromSQLNode(n.parseTree,t,i)},J.fromSQLNode=(e,t,i)=>{c("binary-expression"===e.type,"Invalid expression: not a condition.");const s=U(e);if(void 0!==s){const e=t.get(s.field);return c(j(e,i),"Invalid expression: unsupported field."),new V(e.name,e.type,void 0,s.operator)}let n,r;"column-reference"===e.left.type?(n=e.left,r=e.right):(n=e.right,r=e.left),c("column-reference"===n.type,"Invalid expression: missing column reference.");const a=t.get(n.column);let o;c(j(a,i),"Invalid expression: unsupported field.");const l=T[e.operator],u=function(e){if("expression-list"!==e.type)return;const t=e.value;if(2===t.length&&"binary-expression"===t[0].type&&"current-time"===t[0].left.type&&"interval"===t[0].right.type&&"current-time"===t[1].type&&"interval-period"===t[0].right.qualifier.type){const e=t[0].right.qualifier.period,i=Number.parseFloat(t[0].right.value.value);switch(c(!isNaN(i),`Invalid expression: unsupported value '${i}' for 'In the last' queries.`),e){case"day":return i%7==0?{distance:i/7,unit:"week"}:{distance:i,unit:"day"};case"hour":return{distance:i,unit:"hour"};case"minute":return{distance:i,unit:"minute"};case"month":case"second":case"year":throw new Error(`Unsupported unit '${e}' for 'In the last' queries.`)}}}(r);if(void 0!==u){const e="between"===l?"in_the_last":"not_in_the_last";o=new B(a.name,a.type,u,e)}else if(S(l)){c("expression-list"===r.type,"Invalid expression: invalid value type.");const e=r.value,t=M(e[0]),i=M(e[1]);if(o=new Y(a.name,a.type,[t,i],l),t instanceof Date&&i instanceof Date&&f([t,i])){const e="between"===o.operator?"is_on":"is_not_on";o=new V(a.name,"date",t,e)}}else if(O(l)){c("expression-list"===r.type,"Invalid expression: invalid value type.");const e=r.value.map(M);o=new X(a.name,a.type,e,l)}else{const[t,s]=function(e,t){const i=M(t);switch(e){case"IS":if(null===i)return["is_blank",void 0];if("boolean"==typeof i)return[!0===i?"is_true":"is_false",void 0];throw new Error("Invalid expression: unsupported value for `IS` operator.");case"ISNOT":if(null===i)return["is_not_blank",void 0];throw new Error("Invalid expression: unsupported value for `ISNOT` operator.");case"=":return""===i?["is_empty",""]:"date"===t.type?["is_on",i]:["equal",i];case"<>":return""===i?["is_not_empty",""]:"date"===t.type?["is_not_on",i]:["not_equal",i];case"<":return"date"===t.type||"timestamp"===t.type?["is_before",i]:["less",i];case">":return"date"===t.type||"timestamp"===t.type?["is_after",i]:["greater",i];case"LIKE":return c("string"==typeof i,"Invalid expression: unsupported value for `LIKE` operator."),i.startsWith("%")&&i.endsWith("%")?["contains",i.substring(1,i.length-1)]:i.endsWith("%")?["begins_with",i.substring(0,i.length-1)]:i.startsWith("%")?["ends_with",i.substring(1)]:["equal",i];case"NOT LIKE":return c("string"==typeof i,"Invalid expression: unsupported value for `NOT LIKE` operator."),i.startsWith("%")&&i.endsWith("%")?["not_contains",i.slice(1,i.length-1)]:i.endsWith("%")?["not_begins_with",i.slice(0,i.length-1)]:i.startsWith("%")?["not_ends_with",i.slice(1)]:["not_equal",i];default:const s=T[e];return c(void 0!==s,"Invalid expression: unsupported operator."),[s,i]}}(e.operator,r),n=H(a,i)??a.type;o=new V(a.name,n,s,t)}return o};class Z{constructor(e,t="",i=[],s,n){this.toJSON=async(e,t)=>{const i=this.getUsedLayers(e);return{expressions:this.toGPQuery(i),inputLayers:await this.serializeLayers(i,t)}},this.toGPQuery=(e,t="")=>{const i=[];return this.children.forEach(((s,n)=>{let r=0===n?t:this.operator;if(s instanceof Z){if(!0===s.spatialExpression?.validate()){const t=(({expression:e,operator:t,layer:i,layerList:s})=>{const{spatialRelationship:n,spatialRelationshipParams:r}=e,a=e.selectingLayer;return{operator:t,layer:s.findIndex((e=>e.id===i.id)),selectingLayer:s.findIndex((e=>e.id===a.id)),spatialRel:n,distance:r?.distance,units:r?.units}})({operator:r,expression:s.spatialExpression,layer:this.layer,layerList:e});i.push(t),r="and"}const t=s.toGPQuery(e,r);t.length>0&&i.push(t)}else if(s.validate()){const t=(({expression:e,operator:t,layer:i,layerList:s})=>({operator:t,layer:s.findIndex((e=>e.id===i.id)),where:e.toSQL()}))({operator:r,expression:s,layer:this.layer,layerList:e});i.push(t)}})),i},this.layer=e,this.operator=t,this.children=i,this.spatialExpression=s,this.id=n??h()}static async fromSQL(e,t,i){let n,r;if(""===e)n=new Z(t);else try{const{parseTree:a}=await(0,s.au)(e,t.fieldsIndex),{group:o,errorKey:l}=Z.fromSQLNode(a,t,i);n=o,r=l}catch(e){console.log(e),r=g}return{group:n,errorKey:r}}static fromSQLNode(e,t,i){let s;const n=[];let r;const a=[e];for(;a.length>0;)try{const e=a.pop();if("binary-expression"===e.type&&("AND"===e.operator&&void 0===U(e)||"OR"===e.operator))if(s??(s=e.operator),s===e.operator)a.push(e.right),a.push(e.left);else{const{group:s,errorKey:a}=Z.fromSQLNode(e,t,i);r??(r=a),n.push(s)}else{const s=J.fromSQLNode(e,t.fieldsIndex,i);n.push(s)}}catch(e){console.log(e),r=m}const o=void 0===s?"and":s.toLowerCase();return{group:new Z(t,o,n),errorKey:r}}toSQL(e){const t=this.operator.toUpperCase();return this.children.map((t=>{let i;if(t instanceof Z){const s=t.toSQL(e);""!==s&&(i=`(${s})`)}else t.validate()&&(i=t.toSQL(e));return i})).filter((e=>void 0!==e)).join(` ${t} `)}static async fromJSON(e,t){let i,s;if(e.length<1)i=new Z(t[0]);else{const{group:n,errorKey:r}=await Z._fromJSON(e,t);i=n,s=r}return{group:i,errorKey:s}}static async _fromJSON(e,t){let i,s,n="";const r=[],a=new Set;let o,l;for(let l=0;l<e.length;l++)if(!a.has(l))try{let u,p;const h=e[l];if(Array.isArray(h)){const{group:e,combineOperator:i,errorKey:s}=await Z._fromJSON(h,t);o??(o=s),r.push(e),p=e.layer,u=i}else if("spatialRel"in h){const{layer:i,selectingLayer:s,units:n,distance:c,spatialRel:d,operator:y}=h,f=new G(t[i],t[s],d,{units:n,distance:c}),_=e[l+1];if(Array.isArray(_)){const{group:e,errorKey:i}=await Z._fromJSON(_,t);if(o??(o=i),f.selectingLayer===e.layer)e.spatialExpression=f,r.push(e),a.add(l+1);else{const e=f.selectingLayer,t=new Z(e,y,[],f);r.push(t)}}else{const e=new Z(t[s],y,[],f);r.push(e)}p=t[i],u=y}else{const{where:e,layer:i,operator:s}=h,n=await J.fromSQL(e,t[i].fieldsIndex);r.push(n),p=t[i],u=s}0===l?n=u:(s??(s=u),c(s===u,"Invalid expression group: the group uses more than one logical operator.")),i??(i=p),c(i===p,"Invalid expression group: the group operators on multiple layers.")}catch(e){console.log(e),o=g}return l=void 0===i?new Z(t[0],"and",[]):new Z(i,s??"and",r),{group:l,combineOperator:n,errorKey:o}}getUsedLayersIds(e){return e.add(this.layer.id),void 0!==this.spatialExpression&&e.add(this.spatialExpression.selectingLayer.id),this.children.forEach((t=>{t instanceof Z&&t.getUsedLayersIds(e)})),e}getUsedLayers(e){const t=[...this.getUsedLayersIds(new Set)],i=new Map;e.forEach((e=>i.set(e.id,e)));return t.map((e=>i.get(e)))}async serializeLayers(e,t){let i=[];return i=(await Promise.all(e.map((e=>(0,s.o)(e,t))))).map((e=>(0,n.o)(e,"itemId"))),i}changeTarget(e){return new Z(e,this.operator,[],void 0,this.id)}addDefaultSpatialExpression(e,t){const i=G.getValidSelectingLayers(e,t)[0]??e,s=new G(e,i,o.Intersects),n=new Z(i,"and",[],s),r=[...this.children,n];return new Z(this.layer,this.operator,r,this.spatialExpression,this.id)}addExpression(e){const t=[...this.children,e];return new Z(this.layer,this.operator,t,this.spatialExpression,this.id)}addDefaultExpression(e){const t=J.createDefaultForLayer(this.layer,e);return void 0===t?this:this.addExpression(t)}addGroup(e){const t=[...this.children,e];return new Z(this.layer,this.operator,t,this.spatialExpression,this.id)}addNewGroup(e="and"){const t=new Z(this.layer,e,[],void 0,this.id);return this.addGroup(t)}removeChild(e){return this.children.splice(e,1),new Z(this.layer,this.operator,this.children,this.spatialExpression,this.id)}changeSpatialExpression(e){const{layer:t,children:i}=this;let s=t,n=i;const r=this.spatialExpression?.selectingLayer,a=e.selectingLayer;return r!==a&&(s=a,n=[]),new Z(s,this.operator,n,e,this.id)}clone(){const e=[...this.cloneChildren(this.children)];return new Z(this.layer,this.operator,e,this.spatialExpression,this.id)}cloneChildren(e){return e.map((e=>{if(e instanceof Z){const t=this.cloneChildren(e.children);return new Z(e.layer,e.operator,t,e.spatialExpression,e.id)}return t=e,(0,n.f)(t,5);var t}))}}let ee,te;function ie(e,t="en"){ee=e,te=t}function se(){if(void 0===ee)throw new Error("Translation strings are not loaded.");return ee}const ne=new Map;function re(e,t){const i=`${te}-${e}`;ne.has(i)||ne.set(i,new Intl.NumberFormat(te,{style:"unit",unit:e,unitDisplay:"long"}));const s=ne.get(i).formatToParts(t);return s[s.length-1].value}}}]);